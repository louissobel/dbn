; def:    setCommand
; input:  [y|pixelDataOffset|x|color|return
; output: [|
; state:  assumes there is a valid bitmap of dim 101x101 at pixelDataOffset
; notes:  
@setCommand:
  ; clip color to [0, 100]
  $postSetCommandClipColor
  DUP5
  JUMP($clipColor)
  @postSetCommandClipColor:
  SWAP4
  POP()

  ; Line can call directly into this
@setCommandPenAlreadyClipped:
  
  ; abandon if x or y too big or too small
  ; again taking advantage of unsigned comparison for negative
  ; [y|pixelDataOffset|x|color
  100           ; [100|y|pixelDataOffset|x|color
  DUP1          ; [100|100|y|pixelDataOffset|x|color
  DUP3          ; [y|100|100|y|pixelDataOffset|x|color
  GT($$, $$)    ; [y>100|100|y|pixelDataOffset|x|color
  SWAP1         ; [100|y>100|y|pixelDataOffset|x|color
  DUP5          ; [x|100|y>100|y|pixelDataOffset|x|color
  GT($$, $$)    ; [x>100|y>100|y|pixelDataOffset|x|color
  OR($$, $$)    ; [x>100 or y>100|y|pixelDataOffset|x|color]
  JUMPI($setCommandOutOfBounds, $$)
  ; otherwise, draw!
    ; [y|pixelDataOffset|x|color
    MUL(104, $$)  ; [y*104|pixelDataOffset|x|color
    ADD($$, $$)   ; [y*104+pixelDataOffset|x|color
    ADD($$, $$)   ; [y*104+pixelDataOffset+x|color
    MSTORE8($$, $$)
    JUMP($$) ; return

  @setCommandOutOfBounds:
  ; [y|pixelDataOffset|x|color
  POP()
  POP()
  POP()
  POP()
  JUMP($$)
