; def:    setCommand
; input:  [y|x|color|return
; output: [|
; state:  assumes 0x20 holds the "pixel data offset"
; notes:  
@setCommand:
  ; clamp color to [0, 100]
  $postSetCommandClampColor
  DUP4
  JUMP($clampValue)
  @postSetCommandClampColor:
  SWAP3
  POP()

  ; Line can call directly into this
@setCommandPenAlreadyClamped:
  
  ; abandon if x or y too big or too small
  ; again taking advantage of unsigned comparison for negative
  ; [y|x|color
  100           ; [100|y|x|color
  DUP1          ; [100|100|y|x|color
  DUP3          ; [y|100|100|y|x|color
  GT($$, $$)    ; [y>100|100|y|x|color
  SWAP1         ; [100|y>100|y|x|color
  DUP4          ; [x|100|y>100|y|x|color
  GT($$, $$)    ; [x>100|y>100|y|x|color
  OR($$, $$)    ; [x>100 or y>100|y|x|color
  JUMPI($setCommandOutOfBounds, $$)
  ; otherwise, draw!
    ; [y|x|color
    MUL(104, $$)  ; [y*104|x|color
    ADD($$, $$)   ; [y*104+x|color
    MLOAD(0x20)   ; [pixelDataStart|y*104+x|color
    ADD($$, $$)   ; [pixelDataOffset+y*104+x|color
    MSTORE8($$, $$)
    JUMP($$) ; return

  @setCommandOutOfBounds:
  ; [y|x|color
  POP()
  POP()
  POP()
  JUMP($$)
