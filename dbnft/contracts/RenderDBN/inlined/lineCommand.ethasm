;link:clampValue,linePixels
; def:    lineCommand
; input:  [y1|x1|y0|x0ret
; output: [|
; state:  assumes pixelDataOffset is at 0x20 (delegated assumption from Set)
;         assumes pen color at 0x40
;         assumes 8 words of scratch memory at 0x80
; notes:  the weird argument layout is so we can easily swap a word to bottom of stack
@lineCommand:
  ; [y1|x1|y0|x0
  0x80                  ; [pixelListDst|y1|x1|y0|x0
  SWAP2                 ; [x1|y1|pixelListDst|y0|x0
  MLOAD(0x20)           ; [pixelDataBase|x1|y1|pixelListDst|y0|x0
  SWAP4                 ; [y0|x1|y1|pixelListDst|pixelDataBase|x0
  $postLinePixelsCall   ; [ret|y0|x1|y1|pixelListDst|pixelDataBase|x0
  SWAP6                 ; [x0|y0|x1|y1|pixelListDst|pixelDataBase|ret
  JUMP($linePixels)
  @postLinePixelsCall:

  ; get and clamp pen
  $postLineCommandClampColor
  MLOAD(0x40)
  JUMP($clampValue)
  @postLineCommandClampColor:

  ; [pen

  ; @debug [0xdd]
  ; now copy in from the pixellist to the bitmap
  SHR(0xf8, MLOAD(0x80)) ; [pixelCount|pen
  0x81                   ; [listBase|pixelCount|pen
  0                      ; [i|listBase|pixelCount|pen
  JUMP($lineCommandPixelCopyTest)

  @lineCommandPixelCopyLoop:
    ; [i (guranteed < pixelcount)|listBase|pixelCount|pen
    DUP1       ; [i|i|listBase|pixelCount|pen
    SHL(1, $$) ; [i * 2|i|listBase|pixelCount|pen
    DUP3       ; [listBase|i * 2|i|listBase|PixelCount|pen
    ADD($$, $$); [thisPixel|i|listBase|pixelCount|pen
    SHR(0xF0, MLOAD($$)) ; [loc|i|listBase|pixelCount|pen
    DUP5
    SWAP1
    MSTORE8($$, $$)

    ADD(1, $$) ; increment i

  @lineCommandPixelCopyTest:
    ; [i|listBase|pixelCount
    DUP3
    DUP2
    LT($$, $$)
    JUMPI($lineCommandPixelCopyLoop, $$)


    POP()
    POP()
    POP()
    POP()
    JUMP($$)

