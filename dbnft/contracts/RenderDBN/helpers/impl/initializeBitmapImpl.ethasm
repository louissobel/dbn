; def:    intializeBitmap
; input:  [dst|return
; output: [length
; state:  <none>
; notes:  assumes 101 square bitmap.
;         does not initialize the pixel data itself; if this is called
;         at the end of touched memory that's fine (all zeros)
;         but otherwise could be problematic
@initializeBitmapImpl:
  ; image size is:
  ; header1 + header2 + palette + data
  ; 14 + 40 + 404 + 104*101
  ; 

  ; Get first 30 bytes in place
  ; template
  ; (bitmap is little endian :...)
  ; B M | len   |  res  |  off  |  siz  |  wid  |  hei  |pl |bpp|###
  0x424dd22a000000000000ca010000280000006500000065000000010008000000

  DUP2
  MSTORE($$, $$)
  ; increment dst
  ADD(30, DUP1)
  SWAP1
  POP()

  ; 24 more header bytes
  ; again, remember we're little endian
  ; | comp  | isize | xppm  | yppm  | colors|  impt 
  0x000000000000000000000000000000006500000000000000  ; TODO: we can optimize how we inject the 65
  SHL(64, $$)
  DUP2
  MSTORE($$, $$)
  ADD(24, DUP1)
  SWAP1
  POP()


  ; Fill in the color table...
  ; 101 entries
  0    ; index
  @initializeBitmapColorTableFill:
    ; palette index is "DBN" color : [0, 100]
    ; map that to [0, 255] via:
    ; 255 - ((255 * c) / 100)
    100
    MUL(0xFF, DUP2)
    DIV($$, $$)
    SUB(255, $$)

    ; $1 now has the byte, but we need to triple it (RGB_)
    MUL(0x01010100, $$)

    ; $1 is the four byte palette
    SHL(224, $$)
    SHL(2, DUP2)
    DUP4
    ADD($$, $$)
    MSTORE($$, $$)

    ; Increment index
    ADD(1, $$)
    GT(101, DUP1)
    JUMPI($initializeBitmapColorTableFill, $$)
    POP()

  POP()  ; remove dst
  JUMP($$)
