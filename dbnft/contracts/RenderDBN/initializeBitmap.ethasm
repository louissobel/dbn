; def:    intializeBitmap
; input:  [dst|width|height|return
; output: [length
; state:  <none>
; notes:  does not initialize the pixel data itself; if this is called
;         at the end of touched memory that's fine (all zeros)
;         but otherwise could be problematic
@initializeBitmap:
  ; get image size

  ; get row width
  ; row width dynamic, padded to 4byte multiple
  ; ((width + 4 - 1) // 4) * 4
  ADD(3, DUP2)
  SHR(2, $$)
  SHL(2, $$)

  MUL(DUP4, $$)
  ; $1 is pixel (byte, given 8-bit) count
  ; 14 + 40 + 404(color table)
  ; key number (pixel offset, etc)
  ADD(458, $$)

  ; $1 is filesize

  ; Get first 30 bytes in place
  ; template
  ; (bitmap is little endian :...)
  ; B M | len   |  res  |  off  |  siz  |  wid  |  hei  |pl |bpp|###
  0x424d0000000000000000ca010000280000000000000000000000010008000000

  ; 3 things to inject
  ; length (at << 26 bytes)
  ; width  (at << 10 bytes)
  ; height (at << 6 bytes)
  ; BUT; bitmap is little endian, so we:

  ; Fix endianess for length
  SHL(24, AND(0x000000FF, DUP2))
  SHL(8, AND(0x0000FF00, DUP3))
  SHR(8, AND(0x00FF0000, DUP4))
  SHR(24, AND(0xFF000000, DUP5))
  OR($$, $$)
  OR($$, $$)
  OR($$, $$)

  ; and then push it over
  SHL(208, $$)

  ;  - assume height / width <= 255 :grimace:
  ;  - push over by an extra 24 bits
  SHL(104, DUP5)
  SHL(72, DUP7)
  OR($$, $$)
  OR($$, $$)
  OR($$, $$)

  DUP3
  MSTORE($$, $$)
  ; increment dst
  ADD(30, DUP2)
  SWAP2
  POP()

  ; 24 more header bytes
  ; again, remember we're little endian
  ; | comp  | isize | xppm  | yppm  | colors|  impt 
  0x000000000000000000000000000000006500000000000000
  SHL(64, $$)
  DUP3
  MSTORE($$, $$)
  ADD(24, DUP2)
  SWAP2
  POP()

  ; Fill in the color table...
  ; 101 entries
  0    ; index
  @initializeBitmapColorTableFill:
    ; palette index is "DBN" color : [0, 100]
    ; map that to [0, 255] via:
    ; 255 - ((255 * c) / 100)
    100
    MUL(0xFF, DUP2)
    DIV($$, $$)
    SUB(255, $$)

    ; $1 now has the byte, but we need to triple it (RGB_)
    SHL(8, $$)
    SHL(8, DUP1)
    SHL(8, DUP1)
    OR($$, $$)
    OR($$, $$)

    ; $1 is the four byte palette
    SHL(224, $$)
    SHL(2, DUP2)
    DUP5
    ADD($$, $$)
    MSTORE($$, $$)

    ; Increment index
    ADD(1, $$)
    GT(101, DUP1)
    JUMPI($initializeBitmapColorTableFill, $$)
    POP()

  ; [len|dst|height|width|ret
  SWAP3  ; [width|dst|height|len|ret
  POP()
  POP()
  POP()
  SWAP1
  JUMP($$)
