{
  "initializeBitmap": ";link:initializeBitmapImpl\n\n@initializeBitmap:\n\tJUMP($initializeBitmapImpl)",
  "linePixels": ";link:linePixelsImpl\n\n@linePixels:\n\tJUMP($linePixelsImpl)",
  "paperCommand": ";link:paperCommandImpl\n\n@paperCommand:\n\tMLOAD(0x20) ; get the dst in place (pixeldataoffset)\n\tJUMP($paperCommandImpl)",
  "timeNumber": ";link:timeNumberImpl\n\n@timeNumber:\n\tJUMP($timeNumberImpl)\n",
  "initializeBitmapImpl": "; def:    intializeBitmap\n; input:  [dst|return\n; output: [length\n; state:  <none>\n; notes:  assumes 101 square bitmap.\n;         does not initialize the pixel data itself; if this is called\n;         at the end of touched memory that's fine (all zeros)\n;         but otherwise could be problematic\n@initializeBitmapImpl:\n  ; image size is:\n  ; header1 + header2 + palette + data\n  ; 14 + 40 + 404 + 104*101\n  ; \n\n  ; Get first 30 bytes in place\n  ; template\n  ; (bitmap is little endian :...)\n  ; B M | len   |  res  |  off  |  siz  |  wid  |  hei  |pl |bpp|###\n  0x424dd22a000000000000ca010000280000006500000065000000010008000000\n\n  DUP2\n  MSTORE($$, $$)\n  ; increment dst\n  ADD(30, DUP1)\n  SWAP1\n  POP()\n\n  ; 24 more header bytes\n  ; again, remember we're little endian\n  ; | comp  | isize | xppm  | yppm  | colors|  impt \n  0x000000000000000000000000000000006500000000000000  ; TODO: we can optimize how we inject the 65\n  SHL(64, $$)\n  DUP2\n  MSTORE($$, $$)\n  ADD(24, DUP1)\n  SWAP1\n  POP()\n\n\n  ; Fill in the color table...\n  ; 101 entries\n  0    ; index\n  @initializeBitmapColorTableFill:\n    ; palette index is \"DBN\" color : [0, 100]\n    ; map that to [0, 255] via:\n    ; 255 - ((255 * c) / 100)\n    100\n    MUL(0xFF, DUP2)\n    DIV($$, $$)\n    SUB(255, $$)\n\n    ; $1 now has the byte, but we need to triple it (RGB_)\n    MUL(0x01010100, $$)\n\n    ; $1 is the four byte palette\n    SHL(224, $$)\n    SHL(2, DUP2)\n    DUP4\n    ADD($$, $$)\n    MSTORE($$, $$)\n\n    ; Increment index\n    ADD(1, $$)\n    GT(101, DUP1)\n    JUMPI($initializeBitmapColorTableFill, $$)\n    POP()\n\n  POP()  ; remove dst\n  JUMP($$)\n",
  "linePixelsImpl": "; def:    linePixels\n; input:  [x0|y0|x1|y1|dst|pixelDataBase|ret\n; output: [|\n; notes:  writes up to 101 pairs of (x, y) bytes to dst+1 (number of pairs at dst)\n\n@linePixelsImpl:\n\n  ; increment dst by 1 to leave room for the eventual counter\n  DUP5\n  ADD(1, $$)\n  SWAP5\n  POP()\n\n  ; steep = abs(y1 - y0) > abs(x1 - x0)\n    ; abs(x1 - x0)\n      DUP1\n      DUP4\n      SUB($$, $$)\n      SAR(0xFF, DUP1)\n      DUP2\n      DUP2\n      ADD($$, $$)\n      XOR($$, $$)\n      SWAP1\n      POP()\n    ; abs(y1 - y0)\n      DUP3\n      DUP6\n      SUB($$, $$)\n      SAR(0xFF, DUP1)\n      DUP2\n      DUP2\n      ADD($$, $$)\n      XOR($$, $$)\n      SWAP1\n      POP()\n    GT($$, $$)\n\n  ; if steep:\n  JUMPI($linePixelsNoSteepSwap,   XOR(1, DUP1))\n    ; x0, y0 = y0, x0\n      DUP2\n      SWAP3\n      SWAP2\n      POP()\n\n    ; x1, y1 = y1, x1\n      DUP4\n      SWAP5\n      SWAP4\n      POP()\n\n  @linePixelsNoSteepSwap:\n  ; [steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n\n  ; if x0 > x1: (skip if x0 < x1)\n  DUP4\n  DUP3\n  SLT($$, $$)\n  JUMPI($linePixelsNoXSwap, $$)\n    ; x0, x1 = x1, x0\n      DUP2 \n      SWAP4\n      SWAP2\n      POP()\n    ; y0, y1 = y1, y0\n      DUP3\n      SWAP5\n      SWAP3\n      POP()\n\n  @linePixelsNoXSwap:\n  ; [steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n\n  ; if y0 < y1:\n  ;   ystep = 1\n  ; else:\n  ;   ystep = -1\n    DUP5\n    DUP4\n    SLT($$, $$)\n    DUP1\n    JUMPI($linePixelsYStepFound, $$)\n    NOT($$)\n\n  @linePixelsYStepFound:\n  ; [ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n  \n  ; deltax = x1 - x0\n    DUP3\n    DUP6\n    SUB($$, $$)\n  ; [deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n\n\n  ; deltay = abs(y1 - y0)\n    DUP5\n    DUP8\n    SUB($$, $$)\n    SAR(0xFF, DUP1)\n    DUP2\n    DUP2\n    ADD($$, $$)\n    XOR($$, $$)\n    SWAP1\n    POP()\n  ; [deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n\n  ; error = -deltax / 2\n    SAR(1, DUP2) ; divide by 2 first\n    ADD(1, NOT($$)) ; negative\n  ; [error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n\n\n  ; counter of how many pixels emitted\n  0\n\n  ; y = y0\n  ; for x in range(x0, x1 + 1):\n  ;     if steep:\n  ;         yield (y,x)\n  ;     else:\n  ;         yield (x,y)\n  ;   \n  ;     error = error + deltay\n  ;     if error > 0:\n  ;         y = y + ystep\n  ;         error = error - deltax\n  DUP8\n  DUP8\n\n  @linePixelsLoop:\n  ; [x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n\n  ;;; skip the emit if (y < 0 or y > 100 or x < 0 or x > 100)\n  ;;;   --> we can actually simplify this to x > 100 | y > 100 if we used unsigned comparisons\n    100\n    DUP2\n    GT($$, $$)\n    100\n    DUP4\n    GT($$, $$)\n    JUMPI($linePixelsSkipEmit, OR($$, $$))\n\n  DUP2\n  DUP2\n  ; it's _actually_ [x, y at the head,\n  ; but steep means we skip the flip code, so flip here first\n  ; [yO|xO|x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n  DUP10\n  JUMPI($linePixelsPostPotentialSteepOutputFlip, $$)\n  ; if we're \"steep\", we _skip_ this code, which is why\n  ; the initial yO / xO seem backwards...\n  SWAP1\n\n  @linePixelsPostPotentialSteepOutputFlip:\n  ; write actual data\n\n    ; [y|x\n    MUL(104, $$)\n    ADD($$, $$)\n    DUP15\n    ADD($$, $$)    ; [v|x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n\n    DUP14 ; [dst|v|x|y|counter\n    DUP5  ; [counter|dst|v|x|y|counter\n    ADD($$, $$) ; [loc|v|x|y|counter\n\n    ; loc gets v & 0xFF00\n    ; loc+1 gets v & 0x00FF\n    DUP2              ; [v|loc|v|x|y|counter\n    AND(0xFF00, $$)   ; [v&0xFF00|loc|v|x|y|counter\n    SHR(8, $$)        ; [v&0xFF00>>8|loc|v|x|y|counter\n    DUP2              ; [loc|v&0xFF00|loc|v|x|y|counter\n    MSTORE8($$, $$)   ; [loc|v|x|y|counter\n    SWAP1             ; [v|loc|x|y|counter\n    AND(0xFF, $$)     ; [v&0xFF|loc|x|y|counter\n    SWAP1             ; [loc|v&0xFF|x|y|counter\n    ADD(1, $$)        ; [loc+1|v&0xFF|x|y|counter\n    MSTORE8($$, $$)\n\n    ; increment counter\n    DUP3\n    ADD(2, $$)\n    SWAP3\n    POP()\n\n\n  @linePixelsSkipEmit:\n\n\n  ; [x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n\n  ;     error = error + deltay\n  ;     if error > 0: # skip block if !(error > 0)\n  ;         y = y + ystep\n  ;         error = error - deltax\n  DUP4\n  DUP6\n  ADD($$, $$)\n  0\n  DUP2\n  SGT($$, $$)\n  JUMPI($linePixelsPostErrorUpdate, XOR(1, $$))\n    ; [error'|x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n    DUP3\n    DUP9\n    ADD($$, $$)\n    SWAP3\n    POP()\n\n    DUP7\n    SWAP1()\n    SUB($$, $$)\n\n  @linePixelsPostErrorUpdate:\n    ; error still top of stack, save it\n    SWAP4()\n    POP()\n\n\n  ; loop if x < (x1 + 1)\n  ADD(1, $$)\n  DUP1\n  ADD(1, DUP12)\n  SGT($$, $$)\n  JUMPI($linePixelsLoop, $$)\n\n  ;[x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret\n\n\n  ; *(dst - 1) = counter/2\n  1\n  DUP14      ; [dst|1|x|y|counter\n  SUB($$, $$)\n  DUP4       ; [counter|dst|x|y\n  SHR(1, $$) ; [counter/2\n  SWAP1      \n  MSTORE8($$, $$)\n\n  POP()\n  POP()\n  POP()\n  POP()\n  POP()\n  POP()\n  POP()\n  POP()\n  POP()\n  POP()\n  POP()\n  POP()\n  POP()\n  POP()\n  JUMP($$)\n\n\n  ;    y = y0\n  ;    for x in range(x0, x1 + 1):\n  ;        if steep:\n  ;            yield (y,x)\n  ;        else:\n  ;            yield (x,y)\n  ;\n  ;        error = error + deltay\n  ;        if error > 0:\n  ;            y = y + ystep\n  ;            error = error - deltax\n\n  STOP\n  ",
  "paperCommandImpl": ";link:clampValue\n; def:    paperCommand\n; input:  [dst|color|return\n; output: [|\n; state: \n; notes:  \n@paperCommandImpl:\n  SWAP1\n\n  ; clamp color to [0, 100]\n  $postPaperCommandClampColor\n  SWAP1\n  JUMP($clampValue)\n  @postPaperCommandClampColor:\n\n  ; [color|dst\n  0x0101010101010101010101010101010101010101010101010101010101010101\n  MUL($$, $$)\n\n  ; we need to write 101 * 104 = 10504 = 8 + 328*32 bytes\n  ; so first smash it into place\n  ; then set the cursor to 8 and tick up by 32\n\n  SWAP1           ; [dst|color\n  DUP2            ; [color|dst|color\n  DUP2            ; [dst|color|dst|color\n  MSTORE($$, $$)  ; [dst|color\n\n  ADD(8, $$)      ; [dst'|color\n  0               ; [i|dst|color\n  @paperCommandWriteLoop:\n    DUP3            ; [color|i|dst|color\n    DUP3            ; [dst|color|i|dst|color\n    ADD(32, $$)     ; [dst+32|color|i|dst|color\n    SWAP3           ; [dst|color|i|dst+32|color\n    MSTORE($$, $$)  ; [i|dst+32|color\n\n    ADD(1, $$)      ; [i+1|dst+32|color\n\n    ; top of stack is now how many times we've done this\n    ; we need 328\n    328             ; [328|i+1|dst+32|color\n    DUP2            ; [i+1|328|i+1|dst+32|color\n    LT($$, $$)      ; [keeplooping|i+1|dst+32|color\n\n    JUMPI($paperCommandWriteLoop, $$)\n\n  POP()\n  POP()\n  POP()\n  JUMP($$)\n\n  ",
  "timeNumberImpl": "; def:    timeNumber\n; input:  [d|return\n; output: [t|\n; state:  none\n; notes:  d=1 --> [0,23] hours, d=2 --> [0,59] minutes, d=3 --> [0,59] seconds else 0\n@timeNumberImpl:\n  86400       ; [86400|d|return\n  TIMESTAMP   ; [now|86400|d|return\n  MOD($$, $$) ; [relevant|d|return\n\n  SWAP1\n  JUMPI($timeNumberHours, EQ(1, DUP1))\n  JUMPI($timeNumberMinutes, EQ(2, DUP1))\n  JUMPI($timeNumberSeconds, EQ(3, DUP1))\n  POP()\n  POP()\n  0\n  SWAP1\n  JUMP($$)\n\n  @timeNumberHours:\n    POP()   ; [relevant|ret\n    3600    ; [3600|relevant|ret\n    SWAP1   ; [relevant|3600|ret\n    DIV($$, $$)\n    SWAP1\n    JUMP($$)\n\n  @timeNumberMinutes:\n    POP()   ; [relevant|ret\n    3600    ; [3600|relevant|ret\n    SWAP1   ; [relevant|3600|ret\n    MOD($$, $$) ; [relevant%3600|ret\n    60\n    SWAP1\n    DIV($$, $$)\n    SWAP1\n    JUMP($$)\n\n  @timeNumberSeconds:\n    POP()\n    60\n    SWAP1\n    MOD($$, $$)\n    SWAP1\n    JUMP($$)\n",
  "clampValue": "; def:    clampValue\n; input:  [value|return\n; output: [value|\n; notes:  clips the value to [0, 100]\n@clampValue:\n  ; [value\n  0           ; [0|value\n  DUP1        ; [0|0|value\n  DUP3        ; [value|0|0|value\n  SGT($$, $$) ; [value>0|0|value\n  JUMPI($clampValueGreaterThanZero, $$)\n    ; otherwise, replace it with a zero\n    SWAP1\n  @clampValueGreaterThanZero:\n  POP()\n\n  ; [value\n  100         ; [100|value\n  DUP1        ; [100|100|value\n  DUP3        ; [value|100|100|value\n  SLT($$, $$) ; [value<100|100|value\n  JUMPI($clampValueLessThan100, $$)\n    ; otherwise, replace it with the 100\n    SWAP1\n  @clampValueLessThan100:\n  POP()\n\n  SWAP1\n  JUMP($$)\n",
  "dotGet": ";link:clampValue\n; def:    dotGet\n; input:  [x|y|return\n; output: [value|\n; state:  assumes 0x20 holds the \"pixel data offset\"\n; notes:  \n@dotGet:\n  ; clamp x\n  $postDotGetClampX\n  SWAP1\n  JUMP($clampValue)\n  @postDotGetClampX:\n\n  SWAP1\n  ; clamp y\n  $postDotGetClampY\n  SWAP1\n  JUMP($clampValue)\n  @postDotGetClampY:\n\n  MUL(104, $$)  ; [y*104|x\n  ADD($$, $$)   ; [y*104+x\n  MLOAD(0x20)   ; [pixelDataStart|y*104+x\n  ADD($$, $$)   ; [pixelDataOffset+y*104+x\n  MLOAD($$)     ; [fulldata\n  SHR(248, $$)  ; [byte|return\n  SWAP1         ; [return|byte\n  JUMP($$)\n",
  "envGet": "; def:    envGet\n; input:  [env_base|bit|wordoffset|ret\n; output: [value\n; state:  <none>\n; notes:  climbs environment looking for the variable given by combination\n;         of \"bit\" and wordoffset, remembering the structure of an env:\n;         {bitmap|parent_env|vars...}\n;         Assumes that eventually, some base env will always have a result!\n@envGet:\n  ; load the bitmap\n  DUP1        ; [env_base|env_base|bit|wordoffset\n  MLOAD($$)   ; [bitmap|env_base|bit|wordoffset\n  DUP3        ; [bit|bitmap|env_base|bit|wordoffset\n  AND($$, $$) ; [found|env_base|bit|wordoffset\n  JUMPI($envGetFound, $$)\n  ; otherwise, loop\n  ; [env_base|bit|wordoffset\n  ADD(0x20, $$) ; [env_base+32|bit|wordoffset\n  MLOAD($$)     ; [parent_env_base|bit|wordoffset\n  JUMP($envGet)\n\n@envGetFound:\n  ; [env_base|bit|wordoffset|ret\n  SWAP1        ; [bit|env_base|wordoffset|ret\n  POP()        ; [env_base|wordoffset|ret\n  ADD($$, $$)  ; [value_addr|ret\n  MLOAD($$)    ; [value|ret\n  SWAP1        ; [ret|value\n  JUMP($$)\n",
  "fieldCommand": ";link:lineCommand\n\n; def:    fieldCommand\n; input:  [x0|y0|x1|y1|color|ret\n; output: [|\n; state:  assumes pixelDataOffset is at 0x20 (for Line)\n;         assumes pen is at 0x40\n@fieldCommand:\n  ; not terribly efficient, we're going to just make multiple line calls\n\n  ; swap x0,y0 <> x1,y1 if x1 < x0\n  DUP1 ; [x0|x0|y0|x1|y1|color|ret\n  DUP4 ; [x1|x0|x0|y0|x1|y1|color|ret\n  SGT($$, $$)\n  JUMPI($fieldCommandNoSwap, $$)\n    ; [x0|y0|x1|y1|color|ret\n    SWAP2 ; [x1|y0|x0|y1|color|ret\n    SWAP1 ; [y0|x1|x0|y1|color|ret\n    SWAP3 ; [y1|x1|x0|y0|color|ret\n    SWAP1 ; [x1|y1|x0|y0|color|ret\n\n  @fieldCommandNoSwap:\n    ; [x0|y0|x1|y1|color|ret\n\n\n  ; save current pen, set pen to color\n  MLOAD(0x40) ; [oldPen|x0|y0|x1|y1|color|ret\n  DUP6        ; [color|oldPen|x0|y0|x1|y1|color|ret\n  MSTORE(0x40, $$)\n\n  @fieldCommandLoop:\n    ; [oldPen|x|y0|x1|y1|color|ret\n\n    ; draw a line\n    $fieldCommandPostLineCall\n    DUP3 ; [x|fieldRet|oldPen|x|y0|x1|y1|color|ret\n    DUP5 ; [y0|x|fieldRet|oldPen|x|y0|x1|y1|color|ret\n    DUP2 ; [x|y0|x|fieldRet|oldPen|x|y0|x1|y1|color|ret\n    DUP9 ; [y1|x|y0|x|fieldRet|oldPen|x|y0|x1|y1|color|ret\n    JUMP($lineCommand)\n    @fieldCommandPostLineCall:\n      ; [oldPen|x|y0|x1|y1|color|ret\n\n    ; if x == x1, we're done.\n    ; else increment x and repeat\n    DUP4 ; [x1|oldPen|x|y0|x1|y1|color|ret\n    DUP3 ; [x|x1|oldPen|x|y0|x1|y1|color|ret\n    EQ($$, $$)\n    JUMPI($fieldCommandLoopDone, $$)\n      ; [oldPen|x|y0|x1|y1|color|ret\n      DUP2\n      ADD(1, $$)\n      SWAP2\n      POP()\n      JUMP($fieldCommandLoop)\n\n  @fieldCommandLoopDone:\n    ; [oldPen|x|y0|x1|y1|color|ret\n\n    ; [oldPen|x|y0|x1|y1|color|ret\n    ; restore pen\n    MSTORE(0x40, $$)\n\n  POP()\n  POP()\n  POP()\n  POP()\n  POP()\n  JUMP($$)\n",
  "lineCommand": ";link:clampValue,linePixels\n; def:    lineCommand\n; input:  [y1|x1|y0|x0ret\n; output: [|\n; state:  assumes pixelDataOffset is at 0x20 (delegated assumption from Set)\n;         assumes pen color at 0x40\n;         assumes 8 words of scratch memory at 0x80\n; notes:  the weird argument layout is so we can easily swap a word to bottom of stack\n@lineCommand:\n  ; [y1|x1|y0|x0\n  0x80                  ; [pixelListDst|y1|x1|y0|x0\n  SWAP2                 ; [x1|y1|pixelListDst|y0|x0\n  MLOAD(0x20)           ; [pixelDataBase|x1|y1|pixelListDst|y0|x0\n  SWAP4                 ; [y0|x1|y1|pixelListDst|pixelDataBase|x0\n  $postLinePixelsCall   ; [ret|y0|x1|y1|pixelListDst|pixelDataBase|x0\n  SWAP6                 ; [x0|y0|x1|y1|pixelListDst|pixelDataBase|ret\n  JUMP($linePixels)\n  @postLinePixelsCall:\n\n  ; get and clamp pen\n  $postLineCommandClampColor\n  MLOAD(0x40)\n  JUMP($clampValue)\n  @postLineCommandClampColor:\n\n  ; [pen\n\n  ; @debug [0xdd]\n  ; now copy in from the pixellist to the bitmap\n  SHR(0xf8, MLOAD(0x80)) ; [pixelCount|pen\n  0x81                   ; [listBase|pixelCount|pen\n  0                      ; [i|listBase|pixelCount|pen\n  JUMP($lineCommandPixelCopyTest)\n\n  @lineCommandPixelCopyLoop:\n    ; [i (guranteed < pixelcount)|listBase|pixelCount|pen\n    DUP1       ; [i|i|listBase|pixelCount|pen\n    SHL(1, $$) ; [i * 2|i|listBase|pixelCount|pen\n    DUP3       ; [listBase|i * 2|i|listBase|PixelCount|pen\n    ADD($$, $$); [thisPixel|i|listBase|pixelCount|pen\n    SHR(0xF0, MLOAD($$)) ; [loc|i|listBase|pixelCount|pen\n    DUP5\n    SWAP1\n    MSTORE8($$, $$)\n\n    ADD(1, $$) ; increment i\n\n  @lineCommandPixelCopyTest:\n    ; [i|listBase|pixelCount\n    DUP3\n    DUP2\n    LT($$, $$)\n    JUMPI($lineCommandPixelCopyLoop, $$)\n\n\n    POP()\n    POP()\n    POP()\n    POP()\n    JUMP($$)\n\n",
  "setCommand": ";link:clampValue\n; def:    setCommand\n; input:  [y|x|color|return\n; output: [|\n; state:  assumes 0x20 holds the \"pixel data offset\"\n; notes:  \n@setCommand:\n  ; clamp color to [0, 100]\n  $postSetCommandClampColor\n  DUP4\n  JUMP($clampValue)\n  @postSetCommandClampColor:\n  SWAP3\n  POP()\n\n  ; Line can call directly into this\n@setCommandPenAlreadyClamped:\n  \n  ; abandon if x or y too big or too small\n  ; again taking advantage of unsigned comparison for negative\n  ; [y|x|color\n  100           ; [100|y|x|color\n  DUP1          ; [100|100|y|x|color\n  DUP3          ; [y|100|100|y|x|color\n  GT($$, $$)    ; [y>100|100|y|x|color\n  SWAP1         ; [100|y>100|y|x|color\n  DUP4          ; [x|100|y>100|y|x|color\n  GT($$, $$)    ; [x>100|y>100|y|x|color\n  OR($$, $$)    ; [x>100 or y>100|y|x|color\n  JUMPI($setCommandOutOfBounds, $$)\n  ; otherwise, draw!\n    ; [y|x|color\n    MUL(104, $$)  ; [y*104|x|color\n    ADD($$, $$)   ; [y*104+x|color\n    MLOAD(0x20)   ; [pixelDataStart|y*104+x|color\n    ADD($$, $$)   ; [pixelDataOffset+y*104+x|color\n    MSTORE8($$, $$)\n    JUMP($$) ; return\n\n  @setCommandOutOfBounds:\n  ; [y|x|color\n  POP()\n  POP()\n  POP()\n  JUMP($$)\n"
}