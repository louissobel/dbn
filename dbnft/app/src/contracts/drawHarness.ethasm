; Header / entry point for actually drawing

; Load our "owning contract id" from code to 0x0C
; (that right-aligns it at the word 0x00)
; if it's not present (length zero) this is noop
CODECOPY(0x0C, $metadataOwningContract, #metadataOwningContract)


; ABI:
; - if calldata is empty, then we render
; - otherwise, first byte of calldata determines operation
; - TODO: we should also have a single payable (if value>0) check
ISZERO(CALLDATASIZE)
JUMPI($render, $$)

SHR(0xF8, CALLDATALOAD(0))
;; Jump table for non-render functions:
;;  0xDE: get description data
JUMPI($loadDescription, EQ(0xDE, DUP1))

; revert!
MSTORE8(0x00, 0x40) ; invalid opcode
REVERT(0x00, 1)

; load metadata returns
@loadDescription:
  CODECOPY(0x00, $metadataDescription, #metadataDescription)
  RETURN(0x00, #metadataDescription)

@render:
  ; Initialize the bitmap @ 0x80
  $postDrawHarnessInitializeBitmap
  0x80
  JUMP($initializeBitmap)
  @postDrawHarnessInitializeBitmap:

  ; In case anyone is looking at our memory, give indication
  ; that the bitmap is now fully initialized
  ; (concretely, the editor web interface uses this)
  MSTORE8(0x0B, 1)

  JUMP($dbnDraw)
  @dbnDrawComplete:

    ; return the blob at 0x80, 10962 long (bitmap)
    RETURN(0x80, 10962)


; "inlined" client for helpers, just a jump table

@initializeBitmap:
	JUMP($initializeBitmapImpl)


; def:    intializeBitmap
; input:  [dst|return
; output: [length
; state:  <none>
; notes:  assumes 101 square bitmap.
;         does not initialize the pixel data itself; if this is called
;         at the end of touched memory that's fine (all zeros)
;         but otherwise could be problematic
@initializeBitmapImpl:
  ; image size is:
  ; header1 + header2 + palette + data
  ; 14 + 40 + 404 + 104*101
  ; 

  ; Get first 30 bytes in place
  ; template
  ; (bitmap is little endian :...)
  ; B M | len   |  res  |  off  |  siz  |  wid  |  hei  |pl |bpp|###
  0x424dd22a000000000000ca010000280000006500000065000000010008000000

  DUP2
  MSTORE($$, $$)
  ; increment dst
  ADD(30, DUP1)
  SWAP1
  POP()

  ; 24 more header bytes
  ; again, remember we're little endian
  ; | comp  | isize | xppm  | yppm  | colors|  impt 
  0x000000000000000000000000000000006500000000000000  ; TODO: we can optimize how we inject the 65
  SHL(64, $$)
  DUP2
  MSTORE($$, $$)
  ADD(24, DUP1)
  SWAP1
  POP()


  ; Fill in the color table...
  ; 101 entries
  0    ; index
  @initializeBitmapColorTableFill:
    ; palette index is "DBN" color : [0, 100]
    ; map that to [0, 255] via:
    ; 255 - ((255 * c) / 100)
    100
    MUL(0xFF, DUP2)
    DIV($$, $$)
    SUB(255, $$)

    ; $1 now has the byte, but we need to triple it (RGB_)
    MUL(0x01010100, $$)

    ; $1 is the four byte palette
    SHL(224, $$)
    SHL(2, DUP2)
    DUP4
    ADD($$, $$)
    MSTORE($$, $$)

    ; Increment index
    ADD(1, $$)
    GT(101, DUP1)
    JUMPI($initializeBitmapColorTableFill, $$)
    POP()

  POP()  ; remove dst
  JUMP($$)
; def:    lineCommand
; input:  [y0|x1|y1|x0|ret
; output: [|
; state:  assumes pixelDataOffset is at 0x20 (delegated assumption from Set)
;         assumes pen color at 0x40
; notes:  the weird argument layout is so we can easily swap pen to bottom of stack
@lineCommand:
  ; get pen, then clamp it to [0, 100]
  $postLineCommandClampColor
  MLOAD(0x40)
  JUMP($clampValue)
  @postLineCommandClampColor:

  ; [pen|y0|x1|y1|x0|ret
  SWAP4

  ; [x0|y0|x1|y1|pen|ret

  ;   int dx =  abs(x1-x0), sx = x0<x1 ? 1 : -1;
  ;   int dy = -abs(y1-y0), sy = y0<y1 ? 1 : -1;

  $lineCommandPostYAbsAndSign ; [ret|x0|y0|x1|y1|pen|ret
  DUP3        ; [y0|ret|x0|y0|x1|y1|pen|ret
  DUP6        ; [y1|y0|ret|x0|y0|x1|y1|pen|ret
  JUMP($lineCommandAbsAndSign)
  @lineCommandPostYAbsAndSign:
  ; [signY|abs(y1-y0)|x0|y0|x1|y1|pen|ret


  $lineCommandPostXAbsAndSign ; [ret|signY|abs(y1-y0)|x0|y0|x1|y1|pen|ret
  DUP4        ; [x0|ret|signY|abs(y1-y0)|x0|y0|x1|y1|pen|ret
  DUP7        ; [x1|x0|ret|signY|abs(y1-y0)|x0|y0|x1|y1|pen|ret
  JUMP($lineCommandAbsAndSign)
  @lineCommandPostXAbsAndSign:

  ; [signX|dx|signY|abs(y1-y0)|x0|y0|x1|y1|pen|ret
  SWAP3     ; [abs(y1-y0)|dx|signY|signX|x0|y0|x1|y1|pen|ret
  SUB(0, $$); [dy|dx|signY|signX|x0|y0|x1|y1|pen|ret

  ;   int err = dx+dy;
  DUP2        ; [dx|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
  DUP2        ; [dy|dx|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
  ADD($$, $$) ; [err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret

  @lineCommandLoop:
    ; [err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret

    ; call into set to do the actual (optional) set...
    $lineCommandPostSetCall ; [ret|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    DUP11                   ; [pen|ret|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    DUP8                    ; [x0|pen|ret|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    DUP10                   ; [y0|x0|pen|ret|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    JUMP($setCommandPenAlreadyClamped)       
    @lineCommandPostSetCall:
    ; [err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
  
    ; if (x0==x1 && y0==y1) break;
      DUP8        ; [x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      DUP7        ; [x0|x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      EQ($$, $$)  ; [x0=x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      DUP10       ; [y1|x0=x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      DUP9        ; [y0|y1|x0=x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      EQ($$, $$)  ; [y0=y1|x0=x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      JUMPI($lineCommandDone, AND($$, $$))

  ;     e2 = 2*err;
    ; [err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    DUP1         ; [err|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    MUL(2, $$)   ; [e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret

  ;     if !(e2 < dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
    DUP3         ; [dy|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    DUP2         ; [e2|dy|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    SLT($$, $$)  ; [e2<dy|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    JUMPI($lineCommandLoopNoXIncrement, $$)
      ; [e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      SWAP1       ; [err|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      DUP3        ; [dy|err|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      ADD($$, $$) ; [err'|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      SWAP1       ; [e2|err'|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret

      DUP7        ; [x0|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      DUP7        ; [signX|x0|e2|err'|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      ADD($$, $$) ; [x0'|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      SWAP7       ; [x0|e2|err|dy|dx|signY|signX|x0'|y0|x1|y1|pen|ret
      POP()       ; [e2|err|dy|dx|signY|signX|x0'|y0|x1|y1|pen|ret
    @lineCommandLoopNoXIncrement:

  ;     if !(e2 > dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
    DUP4          ; [dx|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    DUP2          ; [e2|dx|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    SGT($$, $$)   ; [e2<dx|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    JUMPI($lineCommandLoopNoYIncrement, $$)
      ; [e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      SWAP1       ; [err|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      DUP4        ; [dx|err|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      ADD($$, $$) ; [err'|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      SWAP1       ; [e2|err'|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret

      DUP8        ; [y0|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      DUP6        ; [signY|x0|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      ADD($$, $$) ; [y0'|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
      SWAP8       ; [y0|e2|err|dy|dx|signY|signX|x0|y0'|x1|y1|pen|ret
      POP()       ; [e2|err|dy|dx|signY|signX|x0|y0'|x1|y1|pen|ret

    @lineCommandLoopNoYIncrement:
      ; [e2|err|dy|dx|signY|signX|x0'|y0|x1|y1|pen|ret
      POP() ; [err|dy|dx|signY|signX|x0'|y0|x1|y1|pen|ret
      JUMP($lineCommandLoop)

  @lineCommandDone:
    ; [err|dy|dx|signY|signX|x0|y0|x1|y1|pen|ret
    POP()
    POP()
    POP()
    POP()
    POP()
    POP()
    POP()
    POP()
    POP()
    POP()
    JUMP($$)

  ; helper
  ; input:  [c1|c0|ret
  ; output: [signC|abs(c1-c0)
  ; note:   "signC" is 1 if c1>0, -1 else
  @lineCommandAbsAndSign:
    SUB($$, $$) ; [c1-c0
    1           ; [1|c1-c0
    0           ; [0|1|c1-c0
    DUP3        ; [c1-c0|0|1|c1-c0
    SGT($$, $$) ; [c1-c0>0|1|c1-c0
    JUMPI($lineCommandAbsAndSignNotNegative, $$)
      ; [1|c1-c0
      SUB(0, $$)
    @lineCommandAbsAndSignNotNegative:
      ; [signC|c1-c0
      ; multiply $1 by $2
      SWAP1       ; [c1-c0|signC
      DUP2        ; [signC|c1-c0|signC
      MUL($$, $$) ; [abs(c1-x0)|signC|ret
      SWAP2       ; [ret|signC|abs(C1-x0)
      JUMP($$)



; def:    setCommand
; input:  [y|x|color|return
; output: [|
; state:  assumes 0x20 holds the "pixel data offset"
; notes:  
@setCommand:
  ; clamp color to [0, 100]
  $postSetCommandClampColor
  DUP4
  JUMP($clampValue)
  @postSetCommandClampColor:
  SWAP3
  POP()

  ; Line can call directly into this
@setCommandPenAlreadyClamped:
  
  ; abandon if x or y too big or too small
  ; again taking advantage of unsigned comparison for negative
  ; [y|x|color
  100           ; [100|y|x|color
  DUP1          ; [100|100|y|x|color
  DUP3          ; [y|100|100|y|x|color
  GT($$, $$)    ; [y>100|100|y|x|color
  SWAP1         ; [100|y>100|y|x|color
  DUP4          ; [x|100|y>100|y|x|color
  GT($$, $$)    ; [x>100|y>100|y|x|color
  OR($$, $$)    ; [x>100 or y>100|y|x|color
  JUMPI($setCommandOutOfBounds, $$)
  ; otherwise, draw!
    ; [y|x|color
    MUL(104, $$)  ; [y*104|x|color
    ADD($$, $$)   ; [y*104+x|color
    MLOAD(0x20)   ; [pixelDataStart|y*104+x|color
    ADD($$, $$)   ; [pixelDataOffset+y*104+x|color
    MSTORE8($$, $$)
    JUMP($$) ; return

  @setCommandOutOfBounds:
  ; [y|x|color
  POP()
  POP()
  POP()
  JUMP($$)
; def:    paperCommand
; input:  [color|return
; output: [|
; state:  assumes there is a valid bitmap of dim 101x101 at pixelDataOffset
;         (and the pixelDataOffset lives at 0x20)
; notes:  
@paperCommand:
  ; clamp color to [0, 100]
  $postPaperCommandClampColor
  SWAP1
  JUMP($clampValue)
  @postPaperCommandClampColor:

  ; [color
  0x0101010101010101010101010101010101010101010101010101010101010101
  MUL($$, $$)

  ; we need to write 101 * 104 = 10504 = 8 + 328*32 bytes
  ; so first smash it into place
  ; then set the cursor to 8 and tick up by 32

  ; Initialize dst to "pixel data offset" from 0x20
  MLOAD(0x20)     ; [dst|color
  DUP2            ; [color|dst|color
  DUP2            ; [dst|color|dst|color
  MSTORE($$, $$)  ; [dst|color

  ADD(8, $$)      ; [dst'|color
  0               ; [i|dst|color
  @paperCommandWriteLoop:
    DUP3            ; [color|i|dst|color
    DUP3            ; [dst|color|i|dst|color
    ADD(32, $$)     ; [dst+32|color|i|dst|color
    SWAP3           ; [dst|color|i|dst+32|color
    MSTORE($$, $$)  ; [i|dst+32|color

    ADD(1, $$)      ; [i+1|dst+32|color

    ; top of stack is now how many times we've done this
    ; we need 328
    328             ; [328|i+1|dst+32|color
    DUP2            ; [i+1|328|i+1|dst+32|color
    LT($$, $$)      ; [keeplooping|i+1|dst+32|color

    JUMPI($paperCommandWriteLoop, $$)

  POP()
  POP()
  POP()
  JUMP($$)

  ; def:    clampValue
; input:  [value|return
; output: [value|
; notes:  clips the value to [0, 100]
@clampValue:
  ; [value
  0           ; [0|value
  DUP1        ; [0|0|value
  DUP3        ; [value|0|0|value
  SGT($$, $$) ; [value>0|0|value
  JUMPI($clampValueGreaterThanZero, $$)
    ; otherwise, replace it with a zero
    SWAP1
  @clampValueGreaterThanZero:
  POP()

  ; [value
  100         ; [100|value
  DUP1        ; [100|100|value
  DUP3        ; [value|100|100|value
  SLT($$, $$) ; [value<100|100|value
  JUMPI($clampValueLessThan100, $$)
    ; otherwise, replace it with the 100
    SWAP1
  @clampValueLessThan100:
  POP()

  SWAP1
  JUMP($$)
; def:    envGet
; input:  [env_base|bit|wordoffset|ret
; output: [value
; state:  <none>
; notes:  climbs environment looking for the variable given by combination
;         of "bit" and wordoffset, remembering the structure of an env:
;         {bitmap|parent_env|vars...}
;         Assumes that eventually, some base env will always have a result!
@envGet:
  ; load the bitmap
  DUP1        ; [env_base|env_base|bit|wordoffset
  MLOAD($$)   ; [bitmap|env_base|bit|wordoffset
  DUP3        ; [bit|bitmap|env_base|bit|wordoffset
  AND($$, $$) ; [found|env_base|bit|wordoffset
  JUMPI($envGetFound, $$)
  ; otherwise, loop
  ; [env_base|bit|wordoffset
  ADD(0x20, $$) ; [env_base+32|bit|wordoffset
  MLOAD($$)     ; [parent_env_base|bit|wordoffset
  JUMP($envGet)

@envGetFound:
  ; [env_base|bit|wordoffset|ret
  SWAP1        ; [bit|env_base|wordoffset|ret
  POP()        ; [env_base|wordoffset|ret
  ADD($$, $$)  ; [value_addr|ret
  MLOAD($$)    ; [value|ret
  SWAP1        ; [ret|value
  JUMP($$)
; def:    dotGet
; input:  [x|y|return
; output: [value|
; state:  assumes 0x20 holds the "pixel data offset"
; notes:  
@dotGet:
  ; clamp x
  $postDotGetClampX
  SWAP1
  JUMP($clampValue)
  @postDotGetClampX:

  SWAP1
  ; clamp y
  $postDotGetClampY
  SWAP1
  JUMP($clampValue)
  @postDotGetClampY:

  MUL(104, $$)  ; [y*104|x
  ADD($$, $$)   ; [y*104+x
  MLOAD(0x20)   ; [pixelDataStart|y*104+x
  ADD($$, $$)   ; [pixelDataOffset+y*104+x
  MLOAD($$)     ; [fulldata
  SHR(248, $$)  ; [byte|return
  SWAP1         ; [return|byte
  JUMP($$)
; def:    timeNumber
; input:  [d|return
; output: [t|
; state:  none
; notes:  d=1 --> [0,23] hours, d=2 --> [0,59] minutes, d=3 --> [0,59] seconds else 0
@timeNumber:
  86400       ; [86400|d|return
  TIMESTAMP   ; [now|86400|d|return
  MOD($$, $$) ; [relevant|d|return

  SWAP1
  JUMPI($timeNumberHours, EQ(1, DUP1))
  JUMPI($timeNumberMinutes, EQ(2, DUP1))
  JUMPI($timeNumberSeconds, EQ(3, DUP1))
  POP()
  POP()
  0
  SWAP1
  JUMP($$)

  @timeNumberHours:
    POP()   ; [relevant|ret
    3600    ; [3600|relevant|ret
    SWAP1   ; [relevant|3600|ret
    DIV($$, $$)
    SWAP1
    JUMP($$)

  @timeNumberMinutes:
    POP()   ; [relevant|ret
    3600    ; [3600|relevant|ret
    SWAP1   ; [relevant|3600|ret
    MOD($$, $$) ; [relevant%3600|ret
    60
    SWAP1
    DIV($$, $$)
    SWAP1
    JUMP($$)

  @timeNumberSeconds:
    POP()
    60
    SWAP1
    MOD($$, $$)
    SWAP1
    JUMP($$)
