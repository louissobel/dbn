; Header / entry point for actually drawing

; Load our "helper contract address" from code to 0x0C
; (that right-aligns it at the word 0x00)
; if it's not present (length zero) this is noop
CODECOPY(0x0C, $metadataHelperAddress, #metadataHelperAddress)


; ABI:
; - if calldata is empty, then we render
; - otherwise, first byte of calldata determines operation
; - TODO: we should also have a single payable (if value>0) check
ISZERO(CALLDATASIZE)
JUMPI($render, $$)

; TODO: check for Value (this is not a payable contract :)

SHR(0xF8, CALLDATALOAD(0))
;; Jump table for non-render functions:
;;  0xDE: get description data
JUMPI($loadDescription, EQ(0xDE, DUP1))
JUMPI($helperAddress, EQ(0x33, DUP1))

; revert!
MSTORE8(0x00, 0x40) ; invalid opcode
REVERT(0x00, 1)

; loadDescription returns embedded utf8 description string
@loadDescription:
  CODECOPY(0x00, $metadataDescription, #metadataDescription)
  RETURN(0x00, #metadataDescription)

; helperAddress returns the helper address we have stored 
@helperAddress:
  ; it's already loaded into memory (use compile-time length
  ; so that we return an empty value if it's not set)
  RETURN(0x0C, #metadataHelperAddress)


@render:
  ; Initialize the bitmap @ 0x0180
  $postDrawHarnessInitializeBitmap
  0x0180
  JUMP($initializeBitmap)
  @postDrawHarnessInitializeBitmap:

  ; In case anyone is looking at our memory, give indication
  ; that the bitmap is now fully initialized
  ; (concretely, the editor web interface uses this)
  MSTORE8(0x0B, 1)

  JUMP($dbnDraw)
  @dbnDrawComplete:

    ; return the blob at 0x0180, 10962 long (bitmap)
    RETURN(0x0180, 10962)


; "inlined" client for helpers, ~just a jump table

@initializeBitmap:
	JUMP($initializeBitmapImpl)

@paperCommand:
	MLOAD(0x20) ; get the dst in place (pixeldataoffset)
	JUMP($paperCommandImpl)

@linePixels:
	JUMP($linePixelsImpl)

@timeNumber:
	JUMP($timeNumberImpl)
; def:    intializeBitmap
; input:  [dst|return
; output: [length
; state:  <none>
; notes:  assumes 101 square bitmap.
;         does not initialize the pixel data itself; if this is called
;         at the end of touched memory that's fine (all zeros)
;         but otherwise could be problematic
@initializeBitmapImpl:
  ; image size is:
  ; header1 + header2 + palette + data
  ; 14 + 40 + 404 + 104*101
  ; 

  ; Get first 30 bytes in place
  ; template
  ; (bitmap is little endian :...)
  ; B M | len   |  res  |  off  |  siz  |  wid  |  hei  |pl |bpp|###
  0x424dd22a000000000000ca010000280000006500000065000000010008000000

  DUP2
  MSTORE($$, $$)
  ; increment dst
  ADD(30, DUP1)
  SWAP1
  POP()

  ; 24 more header bytes
  ; again, remember we're little endian
  ; | comp  | isize | xppm  | yppm  | colors|  impt 
  0x000000000000000000000000000000006500000000000000  ; TODO: we can optimize how we inject the 65
  SHL(64, $$)
  DUP2
  MSTORE($$, $$)
  ADD(24, DUP1)
  SWAP1
  POP()


  ; Fill in the color table...
  ; 101 entries
  0    ; index
  @initializeBitmapColorTableFill:
    ; palette index is "DBN" color : [0, 100]
    ; map that to [0, 255] via:
    ; 255 - ((255 * c) / 100)
    100
    MUL(0xFF, DUP2)
    DIV($$, $$)
    SUB(255, $$)

    ; $1 now has the byte, but we need to triple it (RGB_)
    MUL(0x01010100, $$)

    ; $1 is the four byte palette
    SHL(224, $$)
    SHL(2, DUP2)
    DUP4
    ADD($$, $$)
    MSTORE($$, $$)

    ; Increment index
    ADD(1, $$)
    GT(101, DUP1)
    JUMPI($initializeBitmapColorTableFill, $$)
    POP()

  POP()  ; remove dst
  JUMP($$)
; def:    paperCommand
; input:  [dst|color|return
; output: [|
; state: 
; notes:  
@paperCommandImpl:
  SWAP1

  ; clamp color to [0, 100]
  $postPaperCommandClampColor
  SWAP1
  JUMP($clampValue)
  @postPaperCommandClampColor:

  ; [color|dst
  0x0101010101010101010101010101010101010101010101010101010101010101
  MUL($$, $$)

  ; we need to write 101 * 104 = 10504 = 8 + 328*32 bytes
  ; so first smash it into place
  ; then set the cursor to 8 and tick up by 32

  SWAP1           ; [dst|color
  DUP2            ; [color|dst|color
  DUP2            ; [dst|color|dst|color
  MSTORE($$, $$)  ; [dst|color

  ADD(8, $$)      ; [dst'|color
  0               ; [i|dst|color
  @paperCommandWriteLoop:
    DUP3            ; [color|i|dst|color
    DUP3            ; [dst|color|i|dst|color
    ADD(32, $$)     ; [dst+32|color|i|dst|color
    SWAP3           ; [dst|color|i|dst+32|color
    MSTORE($$, $$)  ; [i|dst+32|color

    ADD(1, $$)      ; [i+1|dst+32|color

    ; top of stack is now how many times we've done this
    ; we need 328
    328             ; [328|i+1|dst+32|color
    DUP2            ; [i+1|328|i+1|dst+32|color
    LT($$, $$)      ; [keeplooping|i+1|dst+32|color

    JUMPI($paperCommandWriteLoop, $$)

  POP()
  POP()
  POP()
  JUMP($$)

  ; def:    linePixels
; input:  [x0|y0|x1|y1|dst|pixelDataBase|ret
; output: [|
; notes:  writes up to 101 pairs of (x, y) bytes to dst+1 (number of pairs at dst)

@linePixelsImpl:

  ; increment dst by 1 to leave room for the eventual counter
  DUP5
  ADD(1, $$)
  SWAP5
  POP()

  ; steep = abs(y1 - y0) > abs(x1 - x0)
    ; abs(x1 - x0)
      DUP1
      DUP4
      SUB($$, $$)
      SAR(0xFF, DUP1)
      DUP2
      DUP2
      ADD($$, $$)
      XOR($$, $$)
      SWAP1
      POP()
    ; abs(y1 - y0)
      DUP3
      DUP6
      SUB($$, $$)
      SAR(0xFF, DUP1)
      DUP2
      DUP2
      ADD($$, $$)
      XOR($$, $$)
      SWAP1
      POP()
    GT($$, $$)

  ; if steep:
  JUMPI($linePixelsNoSteepSwap,   XOR(1, DUP1))
    ; x0, y0 = y0, x0
      DUP2
      SWAP3
      SWAP2
      POP()

    ; x1, y1 = y1, x1
      DUP4
      SWAP5
      SWAP4
      POP()

  @linePixelsNoSteepSwap:
  ; [steep|x0|y0|x1|y1|dst|pixelDataBase|ret

  ; if x0 > x1: (skip if x0 < x1)
  DUP4
  DUP3
  SLT($$, $$)
  JUMPI($linePixelsNoXSwap, $$)
    ; x0, x1 = x1, x0
      DUP2 
      SWAP4
      SWAP2
      POP()
    ; y0, y1 = y1, y0
      DUP3
      SWAP5
      SWAP3
      POP()

  @linePixelsNoXSwap:
  ; [steep|x0|y0|x1|y1|dst|pixelDataBase|ret

  ; if y0 < y1:
  ;   ystep = 1
  ; else:
  ;   ystep = -1
    DUP5
    DUP4
    SLT($$, $$)
    DUP1
    JUMPI($linePixelsYStepFound, $$)
    NOT($$)

  @linePixelsYStepFound:
  ; [ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret
  
  ; deltax = x1 - x0
    DUP3
    DUP6
    SUB($$, $$)
  ; [deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret


  ; deltay = abs(y1 - y0)
    DUP5
    DUP8
    SUB($$, $$)
    SAR(0xFF, DUP1)
    DUP2
    DUP2
    ADD($$, $$)
    XOR($$, $$)
    SWAP1
    POP()
  ; [deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret

  ; error = -deltax / 2
    SAR(1, DUP2) ; divide by 2 first
    ADD(1, NOT($$)) ; negative
  ; [error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret


  ; counter of how many pixels emitted
  0

  ; y = y0
  ; for x in range(x0, x1 + 1):
  ;     if steep:
  ;         yield (y,x)
  ;     else:
  ;         yield (x,y)
  ;   
  ;     error = error + deltay
  ;     if error > 0:
  ;         y = y + ystep
  ;         error = error - deltax
  DUP8
  DUP8

  @linePixelsLoop:
  ; [x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret

  ;;; skip the emit if (y < 0 or y > 100 or x < 0 or x > 100)
  ;;;   --> we can actually simplify this to x > 100 | y > 100 if we used unsigned comparisons
    100
    DUP2
    GT($$, $$)
    100
    DUP4
    GT($$, $$)
    JUMPI($linePixelsSkipEmit, OR($$, $$))

  DUP2
  DUP2
  ; it's _actually_ [x, y at the head,
  ; but steep means we skip the flip code, so flip here first
  ; [yO|xO|x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret
  DUP10
  JUMPI($linePixelsPostPotentialSteepOutputFlip, $$)
  ; if we're "steep", we _skip_ this code, which is why
  ; the initial yO / xO seem backwards...
  SWAP1

  @linePixelsPostPotentialSteepOutputFlip:
  ; write actual data

    ; [y|x
    MUL(104, $$)
    ADD($$, $$)
    DUP15
    ADD($$, $$)    ; [v|x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret

    DUP14 ; [dst|v|x|y|counter
    DUP5  ; [counter|dst|v|x|y|counter
    ADD($$, $$) ; [loc|v|x|y|counter

    ; loc gets v & 0xFF00
    ; loc+1 gets v & 0x00FF
    DUP2              ; [v|loc|v|x|y|counter
    AND(0xFF00, $$)   ; [v&0xFF00|loc|v|x|y|counter
    SHR(8, $$)        ; [v&0xFF00>>8|loc|v|x|y|counter
    DUP2              ; [loc|v&0xFF00|loc|v|x|y|counter
    MSTORE8($$, $$)   ; [loc|v|x|y|counter
    SWAP1             ; [v|loc|x|y|counter
    AND(0xFF, $$)     ; [v&0xFF|loc|x|y|counter
    SWAP1             ; [loc|v&0xFF|x|y|counter
    ADD(1, $$)        ; [loc+1|v&0xFF|x|y|counter
    MSTORE8($$, $$)

    ; increment counter
    DUP3
    ADD(2, $$)
    SWAP3
    POP()


  @linePixelsSkipEmit:


  ; [x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret

  ;     error = error + deltay
  ;     if error > 0: # skip block if !(error > 0)
  ;         y = y + ystep
  ;         error = error - deltax
  DUP4
  DUP6
  ADD($$, $$)
  0
  DUP2
  SGT($$, $$)
  JUMPI($linePixelsPostErrorUpdate, XOR(1, $$))
    ; [error'|x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret
    DUP3
    DUP9
    ADD($$, $$)
    SWAP3
    POP()

    DUP7
    SWAP1()
    SUB($$, $$)

  @linePixelsPostErrorUpdate:
    ; error still top of stack, save it
    SWAP4()
    POP()


  ; loop if x < (x1 + 1)
  ADD(1, $$)
  DUP1
  ADD(1, DUP12)
  SGT($$, $$)
  JUMPI($linePixelsLoop, $$)

  ;[x|y|counter|error|deltay|deltax|ystep|steep|x0|y0|x1|y1|dst|pixelDataBase|ret


  ; *(dst - 1) = counter/2
  1
  DUP14      ; [dst|1|x|y|counter
  SUB($$, $$)
  DUP4       ; [counter|dst|x|y
  SHR(1, $$) ; [counter/2
  SWAP1      
  MSTORE8($$, $$)

  POP()
  POP()
  POP()
  POP()
  POP()
  POP()
  POP()
  POP()
  POP()
  POP()
  POP()
  POP()
  POP()
  POP()
  JUMP($$)


  ;    y = y0
  ;    for x in range(x0, x1 + 1):
  ;        if steep:
  ;            yield (y,x)
  ;        else:
  ;            yield (x,y)
  ;
  ;        error = error + deltay
  ;        if error > 0:
  ;            y = y + ystep
  ;            error = error - deltax

  STOP
  ; def:    timeNumber
; input:  [d|return
; output: [t|
; state:  none
; notes:  d=1 --> [0,23] hours, d=2 --> [0,59] minutes, d=3 --> [0,59] seconds else 0
@timeNumberImpl:
  86400       ; [86400|d|return
  TIMESTAMP   ; [now|86400|d|return
  MOD($$, $$) ; [relevant|d|return

  SWAP1
  JUMPI($timeNumberHours, EQ(1, DUP1))
  JUMPI($timeNumberMinutes, EQ(2, DUP1))
  JUMPI($timeNumberSeconds, EQ(3, DUP1))
  POP()
  POP()
  0
  SWAP1
  JUMP($$)

  @timeNumberHours:
    POP()   ; [relevant|ret
    3600    ; [3600|relevant|ret
    SWAP1   ; [relevant|3600|ret
    DIV($$, $$)
    SWAP1
    JUMP($$)

  @timeNumberMinutes:
    POP()   ; [relevant|ret
    3600    ; [3600|relevant|ret
    SWAP1   ; [relevant|3600|ret
    MOD($$, $$) ; [relevant%3600|ret
    60
    SWAP1
    DIV($$, $$)
    SWAP1
    JUMP($$)

  @timeNumberSeconds:
    POP()
    60
    SWAP1
    MOD($$, $$)
    SWAP1
    JUMP($$)
; def:    lineCommand
; input:  [y1|x1|y0|x0ret
; output: [|
; state:  assumes pixelDataOffset is at 0x20 (delegated assumption from Set)
;         assumes pen color at 0x40
;         assumes 8 words of scratch memory at 0x80
; notes:  the weird argument layout is so we can easily swap a word to bottom of stack
@lineCommand:
  ; [y1|x1|y0|x0
  0x80                  ; [pixelListDst|y1|x1|y0|x0
  SWAP2                 ; [x1|y1|pixelListDst|y0|x0
  MLOAD(0x20)           ; [pixelDataBase|x1|y1|pixelListDst|y0|x0
  SWAP4                 ; [y0|x1|y1|pixelListDst|pixelDataBase|x0
  $postLinePixelsCall   ; [ret|y0|x1|y1|pixelListDst|pixelDataBase|x0
  SWAP6                 ; [x0|y0|x1|y1|pixelListDst|pixelDataBase|ret
  JUMP($linePixels)
  @postLinePixelsCall:

  ; get and clamp pen
  $postLineCommandClampColor
  MLOAD(0x40)
  JUMP($clampValue)
  @postLineCommandClampColor:

  ; [pen

  ; @debug [0xdd]
  ; now copy in from the pixellist to the bitmap
  SHR(0xf8, MLOAD(0x80)) ; [pixelCount|pen
  0x81                   ; [listBase|pixelCount|pen
  0                      ; [i|listBase|pixelCount|pen
  JUMP($lineCommandPixelCopyTest)

  @lineCommandPixelCopyLoop:
    ; [i (guranteed < pixelcount)|listBase|pixelCount|pen
    DUP1       ; [i|i|listBase|pixelCount|pen
    SHL(1, $$) ; [i * 2|i|listBase|pixelCount|pen
    DUP3       ; [listBase|i * 2|i|listBase|PixelCount|pen
    ADD($$, $$); [thisPixel|i|listBase|pixelCount|pen
    SHR(0xF0, MLOAD($$)) ; [loc|i|listBase|pixelCount|pen
    DUP5
    SWAP1
    MSTORE8($$, $$)

    ADD(1, $$) ; increment i

  @lineCommandPixelCopyTest:
    ; [i|listBase|pixelCount
    DUP3
    DUP2
    LT($$, $$)
    JUMPI($lineCommandPixelCopyLoop, $$)


    POP()
    POP()
    POP()
    POP()
    JUMP($$)

; def:    setCommand
; input:  [y|x|color|return
; output: [|
; state:  assumes 0x20 holds the "pixel data offset"
; notes:  
@setCommand:
  ; clamp color to [0, 100]
  $postSetCommandClampColor
  DUP4
  JUMP($clampValue)
  @postSetCommandClampColor:
  SWAP3
  POP()

  ; Line can call directly into this
@setCommandPenAlreadyClamped:
  
  ; abandon if x or y too big or too small
  ; again taking advantage of unsigned comparison for negative
  ; [y|x|color
  100           ; [100|y|x|color
  DUP1          ; [100|100|y|x|color
  DUP3          ; [y|100|100|y|x|color
  GT($$, $$)    ; [y>100|100|y|x|color
  SWAP1         ; [100|y>100|y|x|color
  DUP4          ; [x|100|y>100|y|x|color
  GT($$, $$)    ; [x>100|y>100|y|x|color
  OR($$, $$)    ; [x>100 or y>100|y|x|color
  JUMPI($setCommandOutOfBounds, $$)
  ; otherwise, draw!
    ; [y|x|color
    MUL(104, $$)  ; [y*104|x|color
    ADD($$, $$)   ; [y*104+x|color
    MLOAD(0x20)   ; [pixelDataStart|y*104+x|color
    ADD($$, $$)   ; [pixelDataOffset+y*104+x|color
    MSTORE8($$, $$)
    JUMP($$) ; return

  @setCommandOutOfBounds:
  ; [y|x|color
  POP()
  POP()
  POP()
  JUMP($$)
; def:    clampValue
; input:  [value|return
; output: [value|
; notes:  clips the value to [0, 100]
@clampValue:
  ; [value
  0           ; [0|value
  DUP1        ; [0|0|value
  DUP3        ; [value|0|0|value
  SGT($$, $$) ; [value>0|0|value
  JUMPI($clampValueGreaterThanZero, $$)
    ; otherwise, replace it with a zero
    SWAP1
  @clampValueGreaterThanZero:
  POP()

  ; [value
  100         ; [100|value
  DUP1        ; [100|100|value
  DUP3        ; [value|100|100|value
  SLT($$, $$) ; [value<100|100|value
  JUMPI($clampValueLessThan100, $$)
    ; otherwise, replace it with the 100
    SWAP1
  @clampValueLessThan100:
  POP()

  SWAP1
  JUMP($$)
; def:    envGet
; input:  [env_base|bit|wordoffset|ret
; output: [value
; state:  <none>
; notes:  climbs environment looking for the variable given by combination
;         of "bit" and wordoffset, remembering the structure of an env:
;         {bitmap|parent_env|vars...}
;         Assumes that eventually, some base env will always have a result!
@envGet:
  ; load the bitmap
  DUP1        ; [env_base|env_base|bit|wordoffset
  MLOAD($$)   ; [bitmap|env_base|bit|wordoffset
  DUP3        ; [bit|bitmap|env_base|bit|wordoffset
  AND($$, $$) ; [found|env_base|bit|wordoffset
  JUMPI($envGetFound, $$)
  ; otherwise, loop
  ; [env_base|bit|wordoffset
  ADD(0x20, $$) ; [env_base+32|bit|wordoffset
  MLOAD($$)     ; [parent_env_base|bit|wordoffset
  JUMP($envGet)

@envGetFound:
  ; [env_base|bit|wordoffset|ret
  SWAP1        ; [bit|env_base|wordoffset|ret
  POP()        ; [env_base|wordoffset|ret
  ADD($$, $$)  ; [value_addr|ret
  MLOAD($$)    ; [value|ret
  SWAP1        ; [ret|value
  JUMP($$)
; def:    dotGet
; input:  [x|y|return
; output: [value|
; state:  assumes 0x20 holds the "pixel data offset"
; notes:  
@dotGet:
  ; clamp x
  $postDotGetClampX
  SWAP1
  JUMP($clampValue)
  @postDotGetClampX:

  SWAP1
  ; clamp y
  $postDotGetClampY
  SWAP1
  JUMP($clampValue)
  @postDotGetClampY:

  MUL(104, $$)  ; [y*104|x
  ADD($$, $$)   ; [y*104+x
  MLOAD(0x20)   ; [pixelDataStart|y*104+x
  ADD($$, $$)   ; [pixelDataOffset+y*104+x
  MLOAD($$)     ; [fulldata
  SHR(248, $$)  ; [byte|return
  SWAP1         ; [return|byte
  JUMP($$)
