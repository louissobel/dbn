; Header / entry point for actually drawing

; Load our "owning contract id" from code to 0x0C
; (that right-aligns it at the word 0x00)
; if it's not present (length zero) this is noop
CODECOPY(0x0C, $metadataOwningContract, #metadataOwningContract)


; ABI:
; - if calldata is empty, then we render
; - otherwise, first byte of calldata determines operation
; - TODO: we should also have a single payable (if value>0) check
ISZERO(CALLDATASIZE)
JUMPI($render, $$)

SHR(0xF8, CALLDATALOAD(0))
;; Jump table for non-render functions:
;;  0xDE: get description data
JUMPI($loadDescription, EQ(0xDE, DUP1))

; revert!
MSTORE8(0x00, 0x40) ; invalid opcode
REVERT(0x00, 1)

; load metadata returns
@loadDescription:
  CODECOPY(0x00, $metadataDescription, #metadataDescription)
  RETURN(0x00, #metadataDescription)

@render:
  ; Initialize the bitmap @ 0x80
  $postDrawHarnessInitializeBitmap
  0x80
  JUMP($initializeBitmap)
  @postDrawHarnessInitializeBitmap:

  ; In case anyone is looking at our memory, give indication
  ; that the bitmap is now fully initialized
  MSTORE8(0x20, 1)

  JUMP($dbnDraw)
  @dbnDrawComplete:

    ; return the blob at 0x80
    ; assumes length is still on top of the stack...
    RETURN(0x80, $$)
; def:    intializeBitmap
; input:  [dst|return
; output: [length
; state:  <none>
; notes:  assumes 101 square bitmap.
;         does not initialize the pixel data itself; if this is called
;         at the end of touched memory that's fine (all zeros)
;         but otherwise could be problematic
@initializeBitmap:
  ; image size is:
  ; header1 + header2 + palette + data
  ; 14 + 40 + 404 + 104*101
  ; 

  ; Get first 30 bytes in place
  ; template
  ; (bitmap is little endian :...)
  ; B M | len   |  res  |  off  |  siz  |  wid  |  hei  |pl |bpp|###
  0x424dd22a000000000000ca010000280000006500000065000000010008000000

  DUP2
  MSTORE($$, $$)
  ; increment dst
  ADD(30, DUP1)
  SWAP1
  POP()

  ; 24 more header bytes
  ; again, remember we're little endian
  ; | comp  | isize | xppm  | yppm  | colors|  impt 
  0x000000000000000000000000000000006500000000000000  ; TODO: we can optimize how we inject the 65
  SHL(64, $$)
  DUP2
  MSTORE($$, $$)
  ADD(24, DUP1)
  SWAP1
  POP()

  ; Fill in the color table...
  ; 101 entries
  0    ; index
  @initializeBitmapColorTableFill:
    ; palette index is "DBN" color : [0, 100]
    ; map that to [0, 255] via:
    ; 255 - ((255 * c) / 100)
    100
    MUL(0xFF, DUP2)
    DIV($$, $$)
    SUB(255, $$)

    ; $1 now has the byte, but we need to triple it (RGB_)
    MUL(0x01010100, $$)

    ; $1 is the four byte palette
    SHL(224, $$)
    SHL(2, DUP2)
    DUP4
    ADD($$, $$)
    MSTORE($$, $$)

    ; Increment index
    ADD(1, $$)
    GT(101, DUP1)
    JUMPI($initializeBitmapColorTableFill, $$)
    POP()

  POP()  ; remove dst
  10962  ; [len|ret
  SWAP1  ; [ret|len
  JUMP($$)
; def:    lineCommand
; input:  [x0|y0|x1|y1|pen|pixelDataOffset|ret
; output: [|
; state:  assumes there is a valid bitmap of dim 101x101 at pixelDataOffset
; notes:  
@lineCommand:
  ; clip pen to [0, 100]
  $postLineCommandClipColor
  DUP6
  JUMP($clipColor)
  @postLineCommandClipColor:
  SWAP5
  POP()


  ; [x0|y0|x1|y1|pen|pixelDataOffset|ret

  ;   int dx =  abs(x1-x0), sx = x0<x1 ? 1 : -1;
  ;   int dy = -abs(y1-y0), sy = y0<y1 ? 1 : -1;

  $lineCommandPostYAbsAndSign ; [ret|x0|y0|x1|y1|pen|pixelDataOffset|ret
  DUP3        ; [y0|ret|x0|y0|x1|y1|pen|pixelDataOffset|ret
  DUP6        ; [y1|y0|ret|x0|y0|x1|y1|pen|pixelDataOffset|ret
  JUMP($lineCommandAbsAndSign)
  @lineCommandPostYAbsAndSign:
  ; [signY|abs(y1-y0)|x0|y0|x1|y1|pen|pixelDataOffset|ret


  $lineCommandPostXAbsAndSign ; [ret|signY|abs(y1-y0)|x0|y0|x1|y1|pen|pixelDataOffset|ret
  DUP4        ; [x0|ret|signY|abs(y1-y0)|x0|y0|x1|y1|pen|pixelDataOffset|ret
  DUP7        ; [x1|x0|ret|signY|abs(y1-y0)|x0|y0|x1|y1|pen|pixelDataOffset|ret
  JUMP($lineCommandAbsAndSign)
  @lineCommandPostXAbsAndSign:

  ; [signX|dx|signY|abs(y1-y0)|x0|y0|x1|y1|pen|pixelDataOffset|ret
  SWAP3     ; [abs(y1-y0)|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
  SUB(0, $$); [dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret

  ;   int err = dx+dy;
  DUP2        ; [dx|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
  DUP2        ; [dy|dx|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
  ADD($$, $$) ; [err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret

  @lineCommandLoop:
    ; [err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret

    ; call into set to do the actual (optional) set...
    $lineCommandPostSetCall ; [ret|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    DUP11                   ; [pen|ret|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    DUP8                    ; [x0|pen|ret|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    DUP14                   ; [pixelDataOffset|x0|pen|ret|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    DUP11                   ; [y0|pixelDataOffset|x0|pen|ret|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    JUMP($setCommandPenAlreadyClipped)       
    @lineCommandPostSetCall:
    ; [err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
  
    ; if (x0==x1 && y0==y1) break;
      DUP8        ; [x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      DUP7        ; [x0|x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      EQ($$, $$)  ; [x0=x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      DUP10       ; [y1|x0=x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      DUP9        ; [y0|y1|x0=x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      EQ($$, $$)  ; [y0=y1|x0=x1|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      JUMPI($lineCommandDone, AND($$, $$))

  ;     e2 = 2*err;
    ; [err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    DUP1         ; [err|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    MUL(2, $$)   ; [e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret

  ;     if !(e2 < dy) { err += dy; x0 += sx; } /* e_xy+e_x > 0 */
    DUP3         ; [dy|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    DUP2         ; [e2|dy|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    SLT($$, $$)  ; [e2<dy|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    JUMPI($lineCommandLoopNoXIncrement, $$)
      ; [e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      SWAP1       ; [err|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      DUP3        ; [dy|err|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      ADD($$, $$) ; [err'|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      SWAP1       ; [e2|err'|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret

      DUP7        ; [x0|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      DUP7        ; [signX|x0|e2|err'|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      ADD($$, $$) ; [x0'|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      SWAP7       ; [x0|e2|err|dy|dx|signY|signX|x0'|y0|x1|y1|pen|pixelDataOffset|ret
      POP()       ; [e2|err|dy|dx|signY|signX|x0'|y0|x1|y1|pen|pixelDataOffset|ret
    @lineCommandLoopNoXIncrement:

  ;     if !(e2 > dx) { err += dx; y0 += sy; } /* e_xy+e_y < 0 */
    DUP4          ; [dx|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    DUP2          ; [e2|dx|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    SGT($$, $$)   ; [e2<dx|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    JUMPI($lineCommandLoopNoYIncrement, $$)
      ; [e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      SWAP1       ; [err|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      DUP4        ; [dx|err|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      ADD($$, $$) ; [err'|e2|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      SWAP1       ; [e2|err'|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret

      DUP8        ; [y0|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      DUP6        ; [signY|x0|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      ADD($$, $$) ; [y0'|e2|err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
      SWAP8       ; [y0|e2|err|dy|dx|signY|signX|x0|y0'|x1|y1|pen|pixelDataOffset|ret
      POP()       ; [e2|err|dy|dx|signY|signX|x0|y0'|x1|y1|pen|pixelDataOffset|ret

    @lineCommandLoopNoYIncrement:
      ; [e2|err|dy|dx|signY|signX|x0'|y0|x1|y1|pen|pixelDataOffset|ret
      POP() ; [err|dy|dx|signY|signX|x0'|y0|x1|y1|pen|pixelDataOffset|ret
      JUMP($lineCommandLoop)

  @lineCommandDone:
    ; [err|dy|dx|signY|signX|x0|y0|x1|y1|pen|pixelDataOffset|ret
    POP()
    POP()
    POP()
    POP()
    POP()
    POP()
    POP()
    POP()
    POP()
    POP()
    POP()
    JUMP($$)

  ; helper
  ; input:  [c1|c0|ret
  ; output: [signC|abs(c1-c0)
  ; note:   "signC" is 1 if c1>0, -1 else
  @lineCommandAbsAndSign:
    SUB($$, $$) ; [c1-c0
    1           ; [1|c1-c0
    0           ; [0|1|c1-c0
    DUP3        ; [c1-c0|0|1|c1-c0
    SGT($$, $$) ; [c1-c0>0|1|c1-c0
    JUMPI($lineCommandAbsAndSignNotNegative, $$)
      ; [1|c1-c0
      SUB(0, $$)
    @lineCommandAbsAndSignNotNegative:
      ; [signC|c1-c0
      ; multiply $1 by $2
      SWAP1       ; [c1-c0|signC
      DUP2        ; [signC|c1-c0|signC
      MUL($$, $$) ; [abs(c1-x0)|signC|ret
      SWAP2       ; [ret|signC|abs(C1-x0)
      JUMP($$)



; def:    setCommand
; input:  [y|pixelDataOffset|x|color|return
; output: [|
; state:  assumes there is a valid bitmap of dim 101x101 at pixelDataOffset
; notes:  
@setCommand:
  ; clip color to [0, 100]
  $postSetCommandClipColor
  DUP5
  JUMP($clipColor)
  @postSetCommandClipColor:
  SWAP4
  POP()

  ; Line can call directly into this
@setCommandPenAlreadyClipped:
  
  ; abandon if x or y too big or too small
  ; again taking advantage of unsigned comparison for negative
  ; [y|pixelDataOffset|x|color
  100           ; [100|y|pixelDataOffset|x|color
  DUP1          ; [100|100|y|pixelDataOffset|x|color
  DUP3          ; [y|100|100|y|pixelDataOffset|x|color
  GT($$, $$)    ; [y>100|100|y|pixelDataOffset|x|color
  SWAP1         ; [100|y>100|y|pixelDataOffset|x|color
  DUP5          ; [x|100|y>100|y|pixelDataOffset|x|color
  GT($$, $$)    ; [x>100|y>100|y|pixelDataOffset|x|color
  OR($$, $$)    ; [x>100 or y>100|y|pixelDataOffset|x|color]
  JUMPI($setCommandOutOfBounds, $$)
  ; otherwise, draw!
    ; [y|pixelDataOffset|x|color
    MUL(104, $$)  ; [y*104|pixelDataOffset|x|color
    ADD($$, $$)   ; [y*104+pixelDataOffset|x|color
    ADD($$, $$)   ; [y*104+pixelDataOffset+x|color
    MSTORE8($$, $$)
    JUMP($$) ; return

  @setCommandOutOfBounds:
  ; [y|pixelDataOffset|x|color
  POP()
  POP()
  POP()
  POP()
  JUMP($$)
; def:    paperCommand
; input:  [color|pixelDataOffset|return
; output: [|
; state:  assumes there is a valid bitmap of dim 101x101 at pixelDataOffset
; notes:  
@paperCommand:
  ; clip color to [0, 100]
  $postPaperCommandClipColor
  SWAP1
  JUMP($clipColor)
  @postPaperCommandClipColor:

  ; [color|pixelDataOffset
  0x0101010101010101010101010101010101010101010101010101010101010101
  MUL($$, $$)

  ; we need to write 101 * 104 = 10504 = 8 + 328*32 bytes
  ; so first smash it into place
  ; then set the cursor to 8 and tick up by 32
  DUP1
  DUP3
  MSTORE($$, $$)

  8
  @paperCommandWriteLoop:
    ; [dst|color|pixelDataOffset
    DUP2            ; [color|dst|color|pixelDataOffset
    DUP2            ; [dst|color|dst|color|pixelDataOffset
    DUP5            ; [pixelDataOffset|dst|color|dst|color|pixelDataOffset
    ADD($$, $$)     ; [pixelDataOffset+dst|color|dst|color|pixelDataOffset
    MSTORE($$, $$)  ; [dst|color|pixelDataOffset
    ADD(32, $$)     ; [dst+32|color|pixelDataOffset
    10504           ; [10504|dst+32|color|pixelDataOffset
    DUP2            ; [dst+32|10504|dst+32|color|pixelDataOffset
    LT($$, $$)      ; [dst+32<10504|dst+32|color|pixelDataOffset
    JUMPI($paperCommandWriteLoop, $$)

  POP()
  POP()
  POP()
  JUMP($$)

  ; def:    clipColor
; input:  [color|return
; output: [color|
; notes:  clips the color to [0, 100]
@clipColor:
  ; [color
  0           ; [0|color
  DUP1        ; [0|0|color
  DUP3        ; [color|0|0|color
  SGT($$, $$) ; [color>0|0|color
  JUMPI($clipColorGreaterThanZero, $$)
    ; otherwise, replace it with a zero
    SWAP1
  @clipColorGreaterThanZero:
  POP()

  ; [color
  100         ; [100|color
  DUP1        ; [100|100|color
  DUP3        ; [color|100|100|color
  SLT($$, $$) ; [color<100|100|color
  JUMPI($clipColorLessThan100, $$)
    ; otherwise, replace it with the 100
    SWAP1
  @clipColorLessThan100:
  POP()

  SWAP1
  JUMP($$)

; def:    envGet
; input:  [env_base|bit|wordoffset|ret
; output: [value
; state:  <none>
; notes:  climbs environment looking for the variable given by combination
;         of "bit" and wordoffset, remembering the structure of an env:
;         {bitmap|parent_env|vars...}
;         Assumes that eventually, some base env will always have a result!
@envGet:
  ; load the bitmap
  DUP1        ; [env_base|env_base|bit|wordoffset
  MLOAD($$)   ; [bitmap|env_base|bit|wordoffset
  DUP3        ; [bit|bitmap|env_base|bit|wordoffset
  AND($$, $$) ; [found|env_base|bit|wordoffset
  JUMPI($envGetFound, $$)
  ; otherwise, loop
  ; [env_base|bit|wordoffset
  ADD(0x20, $$) ; [env_base+32|bit|wordoffset
  MLOAD($$)     ; [parent_env_base|bit|wordoffset
  JUMP($envGet)

@envGetFound:
  ; [env_base|bit|wordoffset|ret
  SWAP1        ; [bit|env_base|wordoffset|ret
  POP()        ; [env_base|wordoffset|ret
  ADD($$, $$)  ; [value_addr|ret
  MLOAD($$)    ; [value|ret
  SWAP1        ; [ret|value
  JUMP($$)
