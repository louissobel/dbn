{
  "callHelper": "; client to call helper contract\n\n; ASSUMES:\n; - helper address is at 0xC\n; - I have 8 words of memory: 0x80\u20130x0160\n\n\n; input: [opcode|arglength|returndst|returnlength|ret\n; notes: arglength needs to include the opcode\n@callHelper:\n  MSTORE8(0x80, $$)\n  0x80\n  MLOAD(0)\n  GAS\n  STATICCALL($$, $$, $$, $$, $$, $$)\n\n  ; assume success...\n  POP()\n  JUMP($$)\n",
  "initializeBitmap": ";link:callHelper\n\n; input:  [dst|return\n; output: [\n@initializeBitmap:\n  458 ; ret length\n  SWAP1 ; ret offset (dst from arg)\n  1     ; arg length\n  0xB1  ; opcode\n\n  ; and we tailcall into the call\n  JUMP($callHelper)\n\n",
  "linePixels": ";link:callHelper\n\n; input [x0|y0|x1|y1|dst|pixelDataBase|return\n; output [t\n@linePixels:\n  MSTORE(0x81, $$) ; x0\n  MSTORE(0xA1, $$) ; y0\n  MSTORE(0xC1, $$) ; x1\n  MSTORE(0xE1, $$) ; y1\n  POP() ; we ignore \"dst\" for the remote client case (always will be 0x80)\n  MSTORE(0x0101, $$) ; pixelDataBase\n\n  0x0100 ; allow the whole scratch space for return\n  0x80  ; return dst\n  0xA1  ; arg length\n  0x1E ; opcode\n\n  ; tailcall straight into the helper\n  JUMP($callHelper)",
  "paperCommand": ";link:callHelper\n\n; input [color|return\n@paperCommand:\n  MSTORE(0x81, $$)\n\n  10504 ; ret length\n  MLOAD(0x20) ; (return data straight to the bitmap)\n  0x21  ; arg length\n  0xAE  ; opcode\n\n  ; and tailcall into the helper\n  JUMP($callHelper)\n",
  "timeNumber": ";link:callHelper\n\n; input [d|return\n; output [t\n@timeNumber:\n  MSTORE(0x81, $$)\n\n  $postTimeNumberHelperCall\n\n\n  0x20 ; ret length\n  0x80 ; ret offsert\n  0x21 ; arg length\n  0xCC ; opcode\n\n  JUMP($callHelper)\n\n  @postTimeNumberHelperCall:\n\n  MLOAD(0x80)\n  SWAP1\n  JUMP($$)\n\n",
  "clampValue": "; def:    clampValue\n; input:  [value|return\n; output: [value|\n; notes:  clips the value to [0, 100]\n@clampValue:\n  ; [value\n  0           ; [0|value\n  DUP1        ; [0|0|value\n  DUP3        ; [value|0|0|value\n  SGT($$, $$) ; [value>0|0|value\n  JUMPI($clampValueGreaterThanZero, $$)\n    ; otherwise, replace it with a zero\n    SWAP1\n  @clampValueGreaterThanZero:\n  POP()\n\n  ; [value\n  100         ; [100|value\n  DUP1        ; [100|100|value\n  DUP3        ; [value|100|100|value\n  SLT($$, $$) ; [value<100|100|value\n  JUMPI($clampValueLessThan100, $$)\n    ; otherwise, replace it with the 100\n    SWAP1\n  @clampValueLessThan100:\n  POP()\n\n  SWAP1\n  JUMP($$)\n",
  "dotGet": ";link:clampValue\n; def:    dotGet\n; input:  [x|y|return\n; output: [value|\n; state:  assumes 0x20 holds the \"pixel data offset\"\n; notes:  \n@dotGet:\n  ; clamp x\n  $postDotGetClampX\n  SWAP1\n  JUMP($clampValue)\n  @postDotGetClampX:\n\n  SWAP1\n  ; clamp y\n  $postDotGetClampY\n  SWAP1\n  JUMP($clampValue)\n  @postDotGetClampY:\n\n  MUL(104, $$)  ; [y*104|x\n  ADD($$, $$)   ; [y*104+x\n  MLOAD(0x20)   ; [pixelDataStart|y*104+x\n  ADD($$, $$)   ; [pixelDataOffset+y*104+x\n  MLOAD($$)     ; [fulldata\n  SHR(248, $$)  ; [byte|return\n  SWAP1         ; [return|byte\n  JUMP($$)\n",
  "envGet": "; def:    envGet\n; input:  [env_base|bit|wordoffset|ret\n; output: [value\n; state:  <none>\n; notes:  climbs environment looking for the variable given by combination\n;         of \"bit\" and wordoffset, remembering the structure of an env:\n;         {bitmap|parent_env|vars...}\n;         Assumes that eventually, some base env will always have a result!\n@envGet:\n  ; load the bitmap\n  DUP1        ; [env_base|env_base|bit|wordoffset\n  MLOAD($$)   ; [bitmap|env_base|bit|wordoffset\n  DUP3        ; [bit|bitmap|env_base|bit|wordoffset\n  AND($$, $$) ; [found|env_base|bit|wordoffset\n  JUMPI($envGetFound, $$)\n  ; otherwise, loop\n  ; [env_base|bit|wordoffset\n  ADD(0x20, $$) ; [env_base+32|bit|wordoffset\n  MLOAD($$)     ; [parent_env_base|bit|wordoffset\n  JUMP($envGet)\n\n@envGetFound:\n  ; [env_base|bit|wordoffset|ret\n  SWAP1        ; [bit|env_base|wordoffset|ret\n  POP()        ; [env_base|wordoffset|ret\n  ADD($$, $$)  ; [value_addr|ret\n  MLOAD($$)    ; [value|ret\n  SWAP1        ; [ret|value\n  JUMP($$)\n",
  "lineCommand": ";link:clampValue,linePixels\n; def:    lineCommand\n; input:  [y1|x1|y0|x0ret\n; output: [|\n; state:  assumes pixelDataOffset is at 0x20 (delegated assumption from Set)\n;         assumes pen color at 0x40\n;         assumes 8 words of scratch memory at 0x80\n; notes:  the weird argument layout is so we can easily swap a word to bottom of stack\n@lineCommand:\n  ; [y1|x1|y0|x0\n  0x80                  ; [pixelListDst|y1|x1|y0|x0\n  SWAP2                 ; [x1|y1|pixelListDst|y0|x0\n  MLOAD(0x20)           ; [pixelDataBase|x1|y1|pixelListDst|y0|x0\n  SWAP4                 ; [y0|x1|y1|pixelListDst|pixelDataBase|x0\n  $postLinePixelsCall   ; [ret|y0|x1|y1|pixelListDst|pixelDataBase|x0\n  SWAP6                 ; [x0|y0|x1|y1|pixelListDst|pixelDataBase|ret\n  JUMP($linePixels)\n  @postLinePixelsCall:\n\n  ; get and clamp pen\n  $postLineCommandClampColor\n  MLOAD(0x40)\n  JUMP($clampValue)\n  @postLineCommandClampColor:\n\n  ; [pen\n\n  ; @debug [0xdd]\n  ; now copy in from the pixellist to the bitmap\n  SHR(0xf8, MLOAD(0x80)) ; [pixelCount|pen\n  0x81                   ; [listBase|pixelCount|pen\n  0                      ; [i|listBase|pixelCount|pen\n  JUMP($lineCommandPixelCopyTest)\n\n  @lineCommandPixelCopyLoop:\n    ; [i (guranteed < pixelcount)|listBase|pixelCount|pen\n    DUP1       ; [i|i|listBase|pixelCount|pen\n    SHL(1, $$) ; [i * 2|i|listBase|pixelCount|pen\n    DUP3       ; [listBase|i * 2|i|listBase|PixelCount|pen\n    ADD($$, $$); [thisPixel|i|listBase|pixelCount|pen\n    SHR(0xF0, MLOAD($$)) ; [loc|i|listBase|pixelCount|pen\n    DUP5\n    SWAP1\n    MSTORE8($$, $$)\n\n    ADD(1, $$) ; increment i\n\n  @lineCommandPixelCopyTest:\n    ; [i|listBase|pixelCount\n    DUP3\n    DUP2\n    LT($$, $$)\n    JUMPI($lineCommandPixelCopyLoop, $$)\n\n\n    POP()\n    POP()\n    POP()\n    POP()\n    JUMP($$)\n\n",
  "setCommand": ";link:clampValue\n; def:    setCommand\n; input:  [y|x|color|return\n; output: [|\n; state:  assumes 0x20 holds the \"pixel data offset\"\n; notes:  \n@setCommand:\n  ; clamp color to [0, 100]\n  $postSetCommandClampColor\n  DUP4\n  JUMP($clampValue)\n  @postSetCommandClampColor:\n  SWAP3\n  POP()\n\n  ; Line can call directly into this\n@setCommandPenAlreadyClamped:\n  \n  ; abandon if x or y too big or too small\n  ; again taking advantage of unsigned comparison for negative\n  ; [y|x|color\n  100           ; [100|y|x|color\n  DUP1          ; [100|100|y|x|color\n  DUP3          ; [y|100|100|y|x|color\n  GT($$, $$)    ; [y>100|100|y|x|color\n  SWAP1         ; [100|y>100|y|x|color\n  DUP4          ; [x|100|y>100|y|x|color\n  GT($$, $$)    ; [x>100|y>100|y|x|color\n  OR($$, $$)    ; [x>100 or y>100|y|x|color\n  JUMPI($setCommandOutOfBounds, $$)\n  ; otherwise, draw!\n    ; [y|x|color\n    MUL(104, $$)  ; [y*104|x|color\n    ADD($$, $$)   ; [y*104+x|color\n    MLOAD(0x20)   ; [pixelDataStart|y*104+x|color\n    ADD($$, $$)   ; [pixelDataOffset+y*104+x|color\n    MSTORE8($$, $$)\n    JUMP($$) ; return\n\n  @setCommandOutOfBounds:\n  ; [y|x|color\n  POP()\n  POP()\n  POP()\n  JUMP($$)\n"
}